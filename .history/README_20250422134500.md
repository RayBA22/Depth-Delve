

# 🌌 Depth Delve

> *Explorez les profondeurs. Survivez à l’enfer. Récupérez des trésors oubliés.*

Bienvenue à **HeavenlydeepHell**, une ville bâtie sur des mines aussi riches que mortelles. Dans cet univers souterrain infesté de créatures hostiles et de pièges, vous incarnez un jeune mineur prêt à braver les ténèbres pour découvrir les plus précieux minerais.

---

## 🎮 À propos du jeu

**Depth Delve** est un jeu vidéo 2D en vue **axonométrique**, développé en **C++** avec la bibliothèque **SFML**. Vous devez explorer des grottes générées aléatoirement, combattre des monstres, éviter les pièges, et collecter un maximum de ressources avant que vos cœurs ne s’épuisent.


## 🧭 Objectifs

- Descendre les différents étages via des portes ou des échelles
- Revenir aux niveaux précédents si nécessaire
- Récupérer les minerais les plus rares
- Survivre le plus longtemps possible

---

## 📸 aperçus du jeu

### 📌 Vue du menu principal  
![Vue du menu principal](assets/captures/menu.png)

### 📌 Exploration d’un étage avec ennemis  
![Exploration d’un étage avec ennemis](assets/captures/exploration.png)

### 📌 Inventaire avec les ressources collectées  
![Inventaire avec les ressources collectées](assets/captures/inventaire.png)

### 📌 Combat contre une créature souterraine  
![Combat contre une créature souterraine](assets/captures/combat.png)

### 📌 Scène de minage avec la pioche  
![Scène de minage](assets/captures/minage.png)


---

## 🕹️ Commandes du jeu

| Action                  | Touche                |
|------------------------|-----------------------|
| Se déplacer            | ZQSD                  |
| Utiliser une échelle   | E                     |
| Ouvrir l’inventaire    | Échap                 |
| Équiper/Déséquiper la pioche | Ctrl gauche     |
| Sauvegarder / Charger  | C                     |
| Lancer une partie      | Entrée (depuis menu)  |

---

## 📦 Fonctionnalités

- 🧱 Étages générés de manière **aléatoire**
- 👾 Ennemis à affronter avec une **pioche**
- 💎 Système de **ressources** à collecter
- 🧭 **Missions** à remplir pour vos supérieurs
- 📦 **Inventaire** avec minerais, stats et informations

---

## 🛠️ Installation

1. Depuis un terminal, placez-vous dans le dossier `build` :
   ```bash
   cd depth-delve-project
   mkdir build
   cd build
   cmake ..
   ```
2. Assurez-vous d’avoir installé `cmake` et `sfml`.
3. Compilez le projet :
   ```bash
   make
   ```

---

## ▶️ Lancement

Une fois la compilation terminée, exécutez le jeu avec :
```bash
../bin/DepthDelve
```

---

## 📁 Arborescence du projet (exemple)

```
depth-delve-project/
├── assets/
├── src/
├── include/
├── build/
├── bin/
└── README.md
```

---

## 🔧 Technologies utilisées

- C++
- [SFML](https://www.sfml-dev.org/) (Simple and Fast Multimedia Library)
- CMake


---

## ⚙️ Contraintes techniques et défis rencontrés

Le développement de **Depth Delve** a représenté un véritable défi, notamment en raison des choix techniques assumés dès le départ :

### 🔄 Séparation entre l’IHM et le modèle

Un effort particulier a été fait pour séparer la **logique métier (modèle)** de l’**interface graphique (IHM)**, afin de rendre le code plus maintenable et modulaire. Chaque entité (joueur, ennemis, niveaux, inventaire…) est gérée de manière indépendante de son affichage, ce qui permet de modifier facilement le comportement sans impacter la partie graphique, et vice versa.

### 🧵 Programmation en C++ bas niveau

Plutôt que de m’appuyer sur des frameworks haut niveau ou des bibliothèques prêtes à l’emploi, j’ai choisi de programmer **en C++ pur**, avec une gestion fine de la mémoire et des structures de données, en limitant volontairement l’usage d’outils modernes (comme le polymorphisme complexe, le multithreading ou les smart pointers avancés).

Cela m’a permis de mieux comprendre les **bases du langage C++**, tout en gardant un contrôle total sur les performances du jeu.

### 🎮 Utilisation minimaliste de SFML

Bien que le projet utilise **SFML** pour la gestion des fenêtres, des textures et des entrées clavier, j’ai volontairement **évité les méthodes avancées** proposées par la bibliothèque (comme les systèmes d’animations, les gestionnaires de scène, ou les classes d’entités intégrées).

À la place, j’ai préféré **concevoir mes propres systèmes de rendu, de collision, de gestion de l’état du jeu et d’inventaire**, pour une meilleure compréhension du fonctionnement interne et un contrôle total sur le gameplay.

---

Ce projet m’a permis d’explorer des aspects fondamentaux du développement de jeux en 2D tout en me confrontant aux réalités de la programmation bas niveau, du design d’architecture logicielle et des contraintes de performance.


---


